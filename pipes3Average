#include <sys/wait.h>
#include <unistd.h>
#include <vector>
#include <iostream>
#include <string>
#include <array>
#include <algorithm>
#include <numeric> // Dla funkcji accumulate

bool pipeRead(int stream, int& value)
{
    int readed = read(stream, &value, sizeof(value));
    if (readed == -1)
    {
        perror("Error reading pipe.");
        exit(EXIT_FAILURE);
    }
    else if (readed == 0)
        return false;
    return true;
}

void pipeWrite(int stream, int value)
{
    if (write(stream, &value, sizeof(value)) == -1)
    {
        perror("Error writing pipe.");
        exit(EXIT_FAILURE);
    }
}

std::vector<std::array<int, 2>> createPipes(int count)
{
    std::vector<std::array<int, 2>> pipes;
    for (int i = 0; i < count; ++i)
    {
        std::array<int, 2> newPipe;
        if (pipe(newPipe.data()) == -1)
        {
            perror("Error creating pipe.");
            exit(EXIT_FAILURE);
        }
        pipes.push_back(newPipe);
    }
    return pipes;
}

int main(int argc, char* argv[])
{
    auto pipes = createPipes(2);

    if (fork() == 0)
    {
        // PIERWSZY PROCES POTOMNY (Child 1): Wczytywanie danych od użytkownika i przekazywanie ich do Pośrednika
        close(pipes[0][0]); 
        close(pipes[1][0]); 
        close(pipes[1][1]); 

        std::cout << "Podaj swoje liczby:\n";

        int value;
        do {
            std::cin >> value;
            if (value > 0)
            {
                pipeWrite(pipes[0][1], value); // Wysyłanie liczby do pośrednika
            }
        } while (value > 0);

        close(pipes[0][1]); // Zamknij potok
        exit(0); // Zakończ proces
    }
    else if (fork() == 0)
    {
        // DRUGI PROCES POTOMNY (Pośrednik): Zapamiętuje liczby, przekazuje je do rodzica i wyświetla wyniki na końcu
        close(pipes[0][1]); 
        close(pipes[1][0]); 

        int value;
        std::vector<int> numbers;

        while (pipeRead(pipes[0][0], value)) 
        {
            numbers.push_back(value);
            pipeWrite(pipes[1][1], value); // Przekazanie liczby do rodzica
        }

        close(pipes[0][0]); 
        close(pipes[1][1]); 

        // Opóźnienie komunikatów Pośrednika
        sleep(5); // Opóźnienie o 5 sekund

        // Wyświetlenie zapamiętanych liczb i średniej
        if (!numbers.empty())
        {
            int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
            double average = static_cast<double>(sum) / numbers.size();

            std::cout << "(Pośrednik): Przeslalem nastepujace liczby: ";
            for (int num : numbers)
                std::cout << num << " ";
            std::cout << "\n(Pośrednik): Srednia wynosi: " << average << "\n";
        }
        else
        {
            std::cout << "(Pośrednik): Brak liczb do wyswietlenia.\n";
        }

        exit(0); // Zakończ proces
    }
    else
    {
        // PROCES RODZICIELSKI: Odbiór danych od pośrednika i ich wyświetlanie
        close(pipes[0][0]); 
        close(pipes[0][1]); 
        close(pipes[1][1]); 

        int value;
        bool firstMessageDisplayed = false;

        while (pipeRead(pipes[1][0], value)) 
        {
            if (!firstMessageDisplayed)
            {
                std::cout << "(Rodzic): Otrzymuje liczby od Pośrednika:\n";
                firstMessageDisplayed = true;
            }
            std::cout << value << "\n"; // Wyświetlenie każdej liczby w momencie jej otrzymania
        }

        close(pipes[1][0]); 

        // Rodzic kończy działanie
        wait(nullptr); // Oczekiwanie na zakończenie Child 1
        wait(nullptr); // Oczekiwanie na zakończenie Child 2
    }

    return 0; // Zamknięcie funkcji main
}
